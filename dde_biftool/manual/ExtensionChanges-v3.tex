\documentclass[11pt]{scrartcl}
% $Id$
\usepackage[scaled=0.9]{helvet}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.9]{beramono}
\usepackage{amsmath,graphicx,upquote}
\usepackage{gensymb,paralist}
\usepackage{mathpazo}
%\usepackage{eulervm}
%\usepackage[notref,notcite]{showkeys}
%\usepackage[charter]{mathdesign}
\usepackage{color,listings,calc,url}
\typearea{12}
\usepackage[pdftex,colorlinks]{hyperref}
\definecolor{darkblue}{cmyk}{1,0,0,0.8}
\definecolor{darkred}{cmyk}{0,1,0,0.7}
\hypersetup{anchorcolor=black,
  citecolor=darkblue, filecolor=darkblue,
  menucolor=darkblue,pagecolor=darkblue,urlcolor=darkblue,linkcolor=darkblue}
%\renewcommand{\floor}{\operatorname{floor}}
\newcommand{\mt}[1]{\mathrm{#1}}
\newcommand{\id}{\mt{I}}
\newcommand{\matlab}{\texttt{Matlab}}
\renewcommand{\i}{\mt{i}}
\renewcommand{\d}{\mathop{}\!\mathrm{d}}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\atant}{\blist{atan2}}
\providecommand{\e}{\mt{e}}
\newcommand{\re}{\mt{Re}}
\newcommand{\im}{\mt{Im}}
\newcommand{\nbc}{n_\mt{bc}}
\newcommand{\gbc}{g_\mt{bc}}
\newcommand{\gic}{g_\mt{ic}}
\newcommand{\nic}{n_\mt{ic}}
\newcommand{\R}{\mathbb{R}}
\usepackage{microtype}

\definecolor{var}{rgb}{0,0.25,0.25}
\definecolor{comment}{rgb}{0,0.5,0}
\definecolor{kw}{rgb}{0,0,0.5}
\definecolor{str}{rgb}{0.5,0,0}
\newcommand{\mlvar}[1]{\lstinline[keywordstyle=\color{var}]!#1!}
\newcommand{\blist}[1]{\mbox{\lstinline!#1!}}
\newlength{\tabw}
\lstset{language=Matlab,%
  basicstyle={\ttfamily\small},%
  commentstyle=\color{comment},%
  stringstyle=\color{str},%
  keywordstyle=\color{kw},%
  identifierstyle=\color{var},%
  upquote=true,%
  deletekeywords={beta,gamma,mesh}%
}
\title{Summary of extensions and changes to DDE-BifTool}
\author{Jan Sieber}\date{}
\begin{document}
\maketitle
\noindent This addendum describes extensions to DDE-BifTool
\cite{ELS01,ELR02,homoclinic,RS07,VLR08}, a bifurcation analysis toolbox
running in \texttt{Matlab}\footnote{\url{http://www.mathworks.com}} or
\texttt{octave}\footnote{\url{http://www.gnu.org/software/octave}}. The
extensions enable continuation of periodic orbit bifurcations for
delay-differential equations with constant or state-dependent delay. A
change of the interface, passing on right-hand sides as function
handles to all DDE-BifTool routines, permits the implementation of all
extensions as separate \emph{extended problems}, re-using the core
DDE-BifTool algorithms for periodic orbits.
\tableofcontents

\section{Overview}
\label{sec:quick}
To get up and running quickly, users familiar with DDE-BifTool should
look at the demo in folder \texttt{minimal\_demo} (script
\texttt{rundemo.m}). The results are pre-computed and stored in
\texttt{mat} files). Otherwise, please see the main manual and the
tutorial demos \texttt{neuron}, \texttt{sd\_demo} and \texttt{hom\_demo}
for an introduction to using basic DDE-BifTool.

\noindent Three additional functions are available now:
\begin{compactitem}
\item \blist{SetupPOfold} to initialize continuation of folds of periodic
  orbits,
\item \blist{SetupTorusBifurcation} to initialize continuation of
  torus bifurcations, and
\item \blist{SetupPeriodDoubling} to initialize
  continuation of period doublings (this is identical to torus
  bifurcations).
\end{compactitem}


% \section{Changes to original user interface}
% \label{sec:orig}
% See \cite{ELS01,ELR02,SER02,RS07,VLR08} for background on the implementation
% of DDE-BifTool.  The only change to the original user interface is
% that all functions calling a user-defined function now have an
% additional argument \mlvar{funcs} (coming at the beginning of the
% argument list). The argument \mlvar{funcs} is a \lstinline{struct}
% containing (among others) the fields
% \begin{compactitem}
% \item \mlvar{sys_rhs},
% \item \mlvar{sys_deriv},
% \item \mlvar{sys_tau},
% \item \mlvar{sys_ntau},
% \item \mlvar{sys_dtau} and
% \item \mlvar{sys_cond}.
% \end{compactitem}
% These fields\footnote{\mlvar{funcs} also contains a few flags
%   described below.} are function handles, replacing the hard-coded
% function names originally used in DDE-BifTool (this simplified
% programming under Matlab versions $<7$ by avoiding
% \lstinline{feval}). This also changes function calls done by the
% user. Affected files are listed in Table~\ref{tab:files}.
% \begin{table}[ht]
%   \centering
%   \begin{tabular}[t]{p{\textwidth}}\hline\noalign{\medskip}
% \noindent\tt   
% \textbf{br\_contn.m
%     br\_recmp.m
%     br\_refin.m
%     br\_stabl.m
%     df\_brnch.m
%     df\_derit.m
%     df\_deriv.m
%     df\_mthod.m}
%     fold\_jac.m
%     hcli\_jac.m
%     hopf\_jac.m
%     mult\_app.m
%     mult\_dbl.m
%     mult\_int.m
%     mult\_one.m
% \textbf{    p\_correc.m
% }    psol\_jac.m
%     p\_stabil.m
%     p\_tau.m
% \textbf{    p\_tofold.m
%     p\_tohcli.m
%     p\_tohopf.m
%     p\_topsol.m
%     p\_tostst.m
% }    p\_tsgn.m
%     root\_app.m
%     root\_cha.m
%     root\_int.m
%     root\_nwt.m
%     stst\_jac.m
% \textbf{    stst\_stabil.m
% }    time\_h.m\\\noalign{\medskip}\hline
%   \end{tabular}
%   \caption{Functions that have gained the additional argument 
%     \mlvar{funcs}. Functions, typically called directly in user scripts, are highlighted in bold.}
%   \label{tab:files}
% \end{table}
% The change permits one to implement some bifurcations by creating an
% \emph{extended} periodic DDE problem, and feeding the extended problem
% into the standard DDE-BifTool routines without requiring re-naming of
% the user-defined function files.
% \begin{quote}
%   \emph{Note that the changed code has not been tested as extensively as the
%   original code. May-be, a modification is missing in some of the more
%   rarely used functions. Please report back on errors that occur in
%   the modified code.}
% \end{quote}
% To enable vectorized calls to user functions and correct treatment of
% periodic orbit bifurcations with state-dependent delays several core
% DDE-BifTool functions listed in Section~\ref{sec:corechanges} had to
% be changed, preserving their original functionality.

\section{Additional functionality}
\label{sec:extra}

The folder \texttt{ddebiftool\_extra\_psol} contains additional
functions that implement tracking of
\begin{compactitem}
\item saddle-nodes (folds),
\item period doublings, and
\item torus bifurcations
\end{compactitem}
of periodic orbits in two parameters. This is done by creating an
\emph{extended} DDE from the user-provided right-hand side. The
periodic orbits of the extended DDEs are then continued using
DDE-BifTool's original routines for periodic orbits.  To access the
additional routines, the folder \texttt{ddebiftool\_extra\_psol} has
to be added to the path, for example:
\begin{lstlisting}
  addpath('../../ddebiftool');            % path to original DDE-BifTool
  addpath('../../ddebiftool_extra_psol'); % path to additional routines
\end{lstlisting}
(adapt to your own folder structure).

Furthermore, the computation of equilibria, periodic orbits and their
stability and local bifurcations is now possible for systems with
state-dependent delays with an arbitrary level of nesting:
\begin{align*}
  \dot x(t)&=f(x(t),x(t-\tau_1),\ldots x(t-\tau_{n_\tau}),p)\mbox{,}\\
\intertext{where}
  \tau_j&=\tau_j(x(t),x(t-\tau_1),\ldots x(t-\tau_{j-1}),p)
  \mbox{,\quad $j=1,\ldots,n_\tau$.}
\end{align*}
Note that the computation of connecting orbits is still restricted to
cases where delays can only depend on the instantaneous argument and
arguments with constant delays.
\subsection{Additional functions of interest in user scripts}
\label{sec:user}

% \subsubsection{\blist{set_funcs}}
% \label{setfuncs}

% \paragraph{Header}
% \
% \begin{lstlisting}
%   function funcs=set_funcs(varargin)
% \end{lstlisting}

% \paragraph{Brief description}
% Creates the structure \blist{funcs} needed for all function calls.

% \paragraph{Inputs}
% Key-value pairs in arbitrary order. Possible keys:
% \begin{compactitem}
% \item \blist{'sys_rhs'}, (\blist{@sys_rhs;} if file
%   \texttt{sys\_rhs.m} is found in path)
% \item \blist{'sys_tau'} ( \blist{@()1;})
% \item \blist{'sys_ntau'} (\blist{@()0;} this is only needed for
%   state-dependent delays),
% \item \blist{'sys_cond'}, (\blist{@dummy_cond;} a dummy procedure,
%     defining no conditions),
% \item \blist{'sys_deri'}, (\blist{@df_deriv;} as provided by DDE-BifTool),
% \item \blist{'sys_dtau'}, (\blist{@df_derit;} as provided by DDE-BifTool),
% \item \blist{'x_vectorized'}, (\blist{false;}) set to true if all
%   user-provided functions are vectorized in their \mlvar{xx} argument.
% \end{compactitem}
% If a key-value pair is not given, the default values (in brackets),
% will be used.
% \paragraph{Output}
% Structure \blist{funcs} that can be passed on to DDE-BifTool routines
% such as \blist{br_contn} etc.

% \paragraph{Examples}
% The function \blist{set_funcs} simplifies the creation of the
% structure \blist{funcs}, which is a new argument to all DDE-BifTool
% routines.  For example, if one wants to study the the Mackey-Glass
% equation \cite{MG2010}
% \begin{displaymath}
%   \dot x(t)=\beta\frac{x(t-\tau)}{1+x(t-\tau)^n}-\gamma x(t)\mbox{,}
% \end{displaymath}
% treating $\gamma=1.0$ as a constant as $p=(\beta,n,\tau)$ as the
% system parameters, one could write
% \begin{lstlisting}
% gamma=1.0;
% f=@(x,xtau,beta,n)beta*xtau/(1+xtau^n)-gamma*x;
% funcs=set_funcs(...
%     'sys_rhs',@(xx,p)f(xx(1,1,:),xx(1,2,:),p(1),p(2)),...
%     'sys_tau',@()3);
% \end{lstlisting}
% All other fields have their default values after this call:
% {\small
% \begin{verbatim}
% funcs = 
%               sys_rhs: [function_handle]
%              sys_ntau: @()0
%               sys_tau: @()3
%              sys_cond: @dummy_cond
%              sys_deri: @(x,p,nx,np,v)df_deriv(funcs,x,p,nx,np,v)
%              sys_dtau: @(it,x,p,nx,np)df_derit(funcs,it,x,p,nx,np)
%          x_vectorized: 0
%                tp_del: 0
%     sys_deri_provided: 0
%     sys_dtau_provided: 0
% \end{verbatim}
% }For the partial derivatives, the default value is the numerical
% approximation routine, provided by DDE-BifTool. There is no need to
% copy and rename \blist{df_deriv.m} or \blist{df_derit.m} anymore. If a
% user has stored his/her right-hand side function in a file, say,
% \texttt{carmodel.m} already in the format DDE-BifTool expects, then
% \blist{funcs} can be created with the call (assuming all other entries
% take their default values)
% \begin{lstlisting}
% funcs=set_funcs('sys_rhs',@carmodel);
% \end{lstlisting}

% \paragraph{Remark}
% The field \blist{funcs.tp_del} is true if \blist{set_funcs} has
% determined that the system has state-dependent delays. This is found
% out through a call
% \begin{lstlisting} 
%   tau=funcs.sys_tau();
% \end{lstlisting}
% enclosed in a \blist{try}--\blist{catch} environment. A check for the
% field \blist{funcs.tp_del} replaces all checks of the type
% \blist{nargin(sys_tau)} in all DDE-BifTool routines to restore
% \texttt{octave} compatibility. See also Section~\ref{sec:octave} for
% further \texttt{octave} compatibility considerations.


\subsubsection{\blist{SetupPOfold} for folds of periodic orbits}
\label{fold}

\paragraph{Header}\
\begin{lstlisting}[basicstyle={\ttfamily\small}]
function [pfuncs,pbranch,suc]=SetupPOfold(funcs,branch,ind,varargin)
\end{lstlisting}

\paragraph{Brief description}
Sets up functions defining right-hand side (in \blist{pfuncs}) and the
initial part of the branch with the first two points (in
\blist{pbranch}) of a curve of folds of periodic orbits.

\paragraph{Inputs}
\begin{compactitem}
\item \blist{funcs}\quad Structure, containing the user-defined right-hand
  side, conditions, delays, etc., as created with \blist{set_funcs}.
\item \blist{branch}\quad Branch of periodic orbits along which the
  fold that the user intends to track was detected. This has to be a
  structure of the format expected and created by DDE-BifTool routines
  such as \blist{df_brnch} or \blist{br_contn}.
\item \blist{ind}\quad index of point along the branch that is close
  to the fold. The periodic orbit \blist{branch.point(ind)} will be
  used to create an initial guess.
\item Optional inputs (key-value pairs in arbitrary order, default in
  brackets):
  \begin{compactitem}
  \item \blist{'contpar'} (\blist{[]}, integer)\quad \emph{index
    of continuation parameters}. This argument can be used in two
    ways:
    \begin{compactitem}
    \item[o] empty (not given): the indices given in
      \blist{branch.parameters.free} will be used.
    \item[o]  array \blist{k} with more than a single integer:  \blist{k}
    will \emph{replace} the parameters in the field
    \blist{branch.parameters.free}.
    \end{compactitem}
  \item \blist{'dir'} (\blist{[]}, integer)\quad \emph{initial direction of
      branch}; index of parameter to be changed for second point along
    branch of folds. If empty, then only a single fold point will be
    computed.
  \item \blist{'step'} (\blist{1e-3}, real) how much the parameter is
    changed. For the second point on the branch the relation holds
    \begin{lstlisting}
pbranch.point(2).parameter(dir)=...
      pbranch.point(1).parameter(dir)+step;
    \end{lstlisting}
  \item \blist{'correc'} (\blist{true}, logical) Apply
    \blist{p_correc} to the initial points.
  \item \blist{'sys_deri'} (\blist{1e-4}), \blist{'sys_dtau'}
    (\blist{1e-4}), \blist{'hjac'} (\blist{1e-4}) deviations used in
    finite-difference formulas. If the user has provided the functions
    \mlvar{sys_deri} and \mlvar{sys_dtau} then these options will not
    be used for constant delays. For state-dependent delays the
    analytic Jacobian of the extended system is not yet implemented
    such that \blist{'hjac'} will be used in the finite-difference
    approximation of the Jacobian.
  \end{compactitem}
\end{compactitem}

\paragraph{Outputs}
If the output \blist{suc} is non-zero, then \blist{pfuncs} and \blist{pbranch} can be fed into \blist{br_contn}. For example,
\begin{lstlisting}
  pbrlong=br_contn(pfuncs,pbranch,100);
\end{lstlisting}
\begin{compactitem}
\item \blist{pfuncs} Structure defining right-hand side of the
  extended DDE for folds of periodic orbits with \emph{constant}
  delays. The structure has an additional field \blist{'get_comp'},
  which can be used to extract the original solution components from
  the solution of the extended system (removing additional components
  and prameters, see example).
\item \blist{pbranch} A DDE-BifTool branch structure, containing the
  first point or the first two points (if desired by setting the
  optional argument \blist{'dir'}).
\item \blist{suc} (logical) indicates success of approximation (and
  correction if desrired) of initial points.
\end{compactitem}

\paragraph{Example}
See \texttt{minimal\_demo}, the Duffing oscillator with delayed feedback of the form
\begin{equation}\label{eq:duff}
%x''(t)+d*x'(t)+a*x(t)+x^3+b*[x(t)-x(t-tau)]=0, parameters [tau,a,b,d]
  \ddot x(t)+d \dot x(t)+a x(t)+x(t)^3+b[x(t)-x(t-\tau)]=0\mbox{,}
\end{equation}
with parameters $p=(\tau,a,b,d)$ (initially $p=(0, 0.5, 0.6, 0.05)$).
After continuation of the family of periodic orbits in $\tau$ ($p_1$)
one has a branch
{\small
\begin{verbatim}
>> per_orb
per_orb = 
       method: [1x1 struct]
    parameter: [1x1 struct]
        point: [1x173 struct]
\end{verbatim}
} with $173$ points, of which point $52$ is close to a fold
\begin{verbatim}
>> ind_fold
ind_fold =    52
>> per_orb.point(ind_fold).stability.mu(1:3)
ans =
   1.0000          
   0.9985          
  -0.0263 + 0.0219i
\end{verbatim}
such that one can call
\begin{lstlisting}
[pfuncs,pbranch]=SetupPOfold(funcs,per_orb,ind_fold,...
    'contpar',[3,1],'dir',3,'step',-1e-3);
pbranch=br_contn(pfuncs,pbranch,60);
\end{lstlisting}
The free parameters and the intial step in $p_3$ (as requested by
the arguments \blist{'dir'} and \blist{'step'}) are
\begin{verbatim}
>> pbranch.parameter.free
ans =     3     1     5     6     7
>> pbranch.point(2).parameter(3)
ans =    0.5990
>> pbranch.point(1).parameter(3)
ans =    0.6000
\end{verbatim}
Note that the extended system introduces the additional parameters
$(\beta,T_\mathrm{copy},\tau_\mathrm{ext})$ (see \cite{S13}), which
are stored at indices $5$ to $7$. The extensions are also visible when
looking at the points:
\begin{verbatim}
>> pbranch.point(1)
ans =    kind: 'psol'
    parameter: [1x7 double]
         mesh: [1x81 double]
       degree: 4
      profile: [4x81 double]
       period: 0.5386
\end{verbatim}
Use \blist{pfuncs.get_comp} to remove all additional components and parameters:
\begin{verbatim}
>> pfuncs.get_comp(pbranch.point(1),'solution')
ans =    kind: 'psol'
    parameter: [0.9343 0.5000 0.6000 0.0500]
         mesh: [1x81 double]
       degree: 4
      profile: [2x81 double]
       period: 0.5386
\end{verbatim}
The function \blist{pfuncs.get_comp} supports the strings
\begin{compactitem}
\item  \blist{'kind'}\quad returning \blist{'POfold'},
\item \blist{'solution'}\quad removing all extensions, returning a
  point of the same format as the original periodic orbits,
\item \blist{'nullvector'}\quad returning the extended components of
  \blist{point.profile} (in the example, rows $3$ and $4$), and the
  extension parameter $\beta$ (in the example in position $5$) as a
  \blist{'psol'} structure,
\item \blist{'delays'}\quad returning the additional parameter(s)
  $\tau_\mathrm{ext}$ (see \cite{S13} for their meaning).
\end{compactitem}
\paragraph{Warning}
For problems with constant delays the extended problem \mlvar{pfuncs}
introduces $n_\tau(n_\tau+1)/2$ additional delays as parameter
$\tau_\mt{ext}$. For problems with state-dependent delays the
additional delays do not show up as additional parameters. However,
the number of additional delays is $n_\tau(n_\tau+1)$. Since the
user-defined functions have to be called at all delay-shifted
collocation points the computations may become slow for problems with
many delays (particularly for state-dependent delay problems).

\subsubsection{\blist{SetupTorusBifurcation} for torus bifurcations}
\label{sec:torusbif}

\paragraph{Header}\
\begin{lstlisting}
function [trfuncs,trbranch,suc]=SetupTorusBifurcation(...
                                         funcs,branch,ind,varargin)
\end{lstlisting}

\paragraph{Brief description}
Sets up the right-hand side (in \blist{trfuncs}) and the first two
points (in \blist{trbranch}) of a curve of torus bifurcations or
period doublings of periodic orbits (which one depends on the Floquet
multipliers of \blist{branch.point(ind)}). The meaning of inputs and
outputs are the same as for \blist{SetupPOfold}, except that the
points on the resulting branch lie on a torus or period doubling
bifurcation curve. Also, the right-hand side of the extended DDE is
different from the corresponding output of \blist{SetupPOfold} (see
\cite{S13} for the extended system).

\paragraph{Example}
(See again \texttt{minimal\_demo}.) The point with index
\blist{ind_tr1} has two complex Floquet multipliers near the unit
circle: {\small
\begin{verbatim}
>> per_orb.point(ind_tr1).stability.mu(1:5)
ans =
   1.1643          
  -0.6292 + 0.8380i
  -0.6292 - 0.8380i
   1.0000          
   0.5968          
\end{verbatim}
} So, one can call
\begin{lstlisting}
[trfuncs,trbranch1]=SetupTorusBifurcation(funcs,per_orb,ind_tr1,...
    'contpar',[3,1],'dir',3,'step',-1e-3);
trbranch1=br_contn(trfuncs,trbranch1,50);
\end{lstlisting}
to continue the torus bifurcation in the two parameters $(\tau,b)$. An
interesting parameter to watch during torus continuation is $\omega$,
the first extended parameter, which is the angle of the complex
Floquet multipliers on the unit circle in multiples of $\pi$ (so, if
the Floquet multiplier is at $-1$, $\omega$ equals $1$ for period doublings).

\paragraph{Warning}
For problems with state-dependent delays the extended problem
\mlvar{pfuncs} introduces $n_\tau(n_\tau+1)$ additional delays. The
additional delays do not show up as additional parameters.  Since the
user-defined functions have to be called at all delay-shifted
collocation points the computations may become slow for problems with
many delays.

\subsubsection{\blist{SetupPeriodDoubling} for period doublings}
\label{sec:pd}
\paragraph{Header}\ 
\begin{lstlisting}
function [trfuncs,trbranch,suc]=SetupPeriodDoubling(...
                                         funcs,branch,ind,varargin)
\end{lstlisting}
This function is a wrapper, just calling
\blist{SetupTorusBifurcation}, to avoid the misleading name. The free
parameter $\omega$ equals unity for period doublings (corresponding to
a rotation by $\pi$).

% \subsection{Vectorization}\label{sec:vectorization}
% Continuation of periodic orbits has partial support of
% vectorization. If one wants to use this feature the user routines
% \begin{compactitem}
% \item \blist{funcs.sys_rhs(xx,p)},
% \item \blist{funcs.sys_deri(xx,p,nx,np,v)},
% \item \blist{funcs.sys_tau(it,xx,p)} (for state-dependent delays),
% \item \blist{funcs.sys_dtau(it,xx,p,nx,np)} (for state-dependent delays)
% \end{compactitem}
% have to be callable with an $n\times (n_\tau+1)\times n_\mt{vec}$
% dimensional argument \mlvar{xx} ($n$ is the dimension of the system,
% $n_\tau$ is the number of delays and $n_\mt{vec}$ is a positive
% integer. All other arguments will have their usual dimensions. Then
% one can add the key-value pair \blist{'x_vectorized',true} to the call
% to \blist{set_funcs}. This may provide moderate speed-up at the cost
% of more memory consumption if the size of the mesh is large. For
% example, in the above example, one would have to change to
% \begin{lstlisting}
% gamma=1.0;
% f=@(x,xtau,beta,n)beta*xtau./(1+xtau.^n)-gamma*x;
% funcs=set_funcs(...
%     'sys_rhs',@(xx,p)f(xx(1,1,:),xx(1,2,:),p(1),p(2)),...
%     'sys_tau',@()3,...
%     'x_vectorized',true);  
% \end{lstlisting}
% gaining a speed-up of factor $\approx 7.5$ (depending on the machine
% and version of Matlab).
% \begin{compactitem}
% \item Vectorization has only one effect: in the assembly of the
%   Jacobian and residual for periodic orbits (\mlvar{psol_jac}) the
%   user functions \blist{funcs.sys_rhs}, \blist{funcs.sys_deri} and
%   \blist{funcs.sys_dtau} are called with an array containing
%   \mlvar{xx} for all collocation points simultaneously.
% \item The numerical approximation routines \mlvar{df_deriv} and
%   \mlvar{df_derit} (which are defaults for \blist{funcs.sys_deriv} and
%   \blist{funcs.sys_dtau}) support this type of vectorization.
% \item If the structure \blist{funcs} indicates vectorization, the
%   extended systems for period orbit bifurcations will be vectorized, too.
% \item The continuation for connecting orbits (points of type
%   \blist{'hcli'}) does not yet support vectorization.
% \item See demos for examples of vectorization.
% \end{compactitem}


\section{Changes of functionality or code in core DDE-BifTool
  routines}
\label{sec:corechanges}
Substantial changes to the following core DDE-BifTool routines were
made. The updates of the core routines are placed in the folder
\texttt{ddebiftool\_extra\_psol/}, keeping the original version in the
folder \texttt{ddebiftool/}.

\paragraph{\blist{psol_jac}}
Enabled vectorization, re-use for Floquet multipliers and vectors, and
nested state-dependent delays. additional optional inputs (as
name-value pairs):
\begin{compactitem}
\item \blist{'wrapJ'} (default \blist{true}): if \blist{false} mesh
  gets extended backward and forward in time to cover all delayed time
  points. For \blist{wrapJ==false} no augmentation is done (that is,
  derivatives w.r.t. period or parameters are not calculated) and no
  phase or boundary conditions are appended to output matrix
  \mlvar{J}.
\item \blist{'bc'} (default \blist{true}): controls whether to append
  boundary conditions.
\item \blist{'c_is_tvals'} (default \blist{false}): entries of
  argument \blist{c} are interpreted as the collocation points in the
  full interval (usually \blist{c} is empty or giving the collocation
  points relative to a subinterval). The residual is only calculated
  in these points (incompatible with \blist{'bc'==true}).
\item \blist{'Dtmat'} (default \blist{eye(size(psol_prof,1))}):
  pre-factor in front of time derivative. This permits evaluation of
  algebraic constraints.
\end{compactitem}
Additional outputs:
\begin{compactitem}
\item additional output \mlvar{tT} (array of delays, scaled by period)
\item additional output \mlvar{extmesh} (mesh of time points extended
  back to \blist{-max(tT(:))} if \blist{wrapJ} is \blist{false},
  otherwise equal to argument \blist{mesh}.
\end{compactitem}
The loops are re-arranged to enable a single vectorized call of the
user functions in the new function \mlvar{psol_sysvals}. Moreover, the
evaluation of \blist{xx} at points in $[0,1]$ now uses
\blist{psol_eva} to avoid code repetition.

\paragraph{\blist{p_correc}} Changed to avoid code duplication and
permit finding of zero-crossings of state-dependent delays with
arbitrary levels of nesting. The original contained a large chunk of
code repeating code from \blist{psol_jac} to create a constraint of
the form $\tau_j(t_z)=0$, $\tau'_j(t_z)=0$ for a fixed
$t_z\in[0,1]$. This code has been replaced by an addiitonal function
\blist{delay_zero_cond}, which in turn calls the now more flexible
\blist{psol_jac} to perform the calculations.

\paragraph{\blist{mult_app}}Changed to avoid code duplication.
\begin{compactitem}
\item Has second (optional) output argument \mlvar{eigenfuncs},
  returning the eigenfunctions on the extended mesh \mlvar{extmesh}
  as output by \blist{psol_jac}. The extended mesh (\mlvar{extmesh}
  is the third output in this case.
\item The original version repeated the code for the Jacobian from
  \blist{psol_jac} and appended code for calculating the monodromy
  matrix. These two parts have been replaced by calls to the new more
  flexible \blist{psol_jac} and the manual calculation of the
  monodromy matrix has been replaced by a call to the backslash
  operator.
\item If the delays are negative another (more general, but possibly
  more expensive) algorithm is used. The Jacobian $J$ on
  \mlvar{extmesh}, as output by \mlvar{psol_jac} has dimensions
  $N_r\times
  N_c=\blist{n*(length(mesh)-1)}\times\blist{n*length(extmesh)}$.  We
  solve an augmented and a generalized eigenvalue problem. Let
  $N_\mt{ext}=N_c-N_r$ be the difference between the column and row
  dimensions of the unwrapped Jacobian $J$. Then the generalized
  eigenvalue problem for the eigenpair ($\mu,v)$ is
  \begin{displaymath}
    \begin{bmatrix}
      J\\
      \begin{matrix}
       0_{N_\mt{ext}\times (N_c-N_\mt{ext})}& \id_{N_\mt{ext}} 
      \end{matrix}
    \end{bmatrix}
    v=\mu
    \begin{bmatrix}
      0_{N_r\times N_c}\\
      \begin{matrix}
        \id_{N_\mt{ext}} & 0_{N_\mt{ext}\times (N_c-N_\mt{ext})}
      \end{matrix}
    \end{bmatrix}v\mbox{.}
  \end{displaymath}
  This generalized eigenvalue problem can in principle also be used to
  detect bifurcations of periodic orbits with delays of mixed
  signs. It gives up to numerical round-off errors results that are
  identical to the results from the monodromy matrix used in the
  original code. However, it operates on a pair of large full
  matrices, becoming expensive for large delays or fine
  discretizations.
\end{compactitem}

\paragraph{\blist{p_topsol}} Uses the general routine
\blist{mult_crit} instead of \blist{mult_dbl} and \blist{mult_one} to
compute eigenfunction for critical Floquet multipliers. This avoids
code duplication. Both, \blist{mult_dbl} and \blist{mult_one},
originally duplicated code from the original \blist{psol_jac} and
\blist{mult_app}. The routine \blist{mult_crit} calls \blist{mult_app}
instead.

\paragraph{\blist{psol_eva}, \blist{p_tau}, \blist{p_tsgn},
  \blist{poly_elg}, \blist{poly_del}, \blist{poly_lgr},
  \blist{poly_dla}} Changed to support and speed up call with many
evaluation points.


\paragraph{\blist{df_deriv} and \blist{df_derit}}
Both functions have been amended to enable (pass on) vectorization
such that they can now perform the requested operation for arguments
\blist{xx} of size $n\times (n_\tau+1)\times n_\mt{vec}$ and return
Jacobians of the corresponding shape. They also apply central
difference formulas, making them slower, but potentially more
accurate.  Note that this may result in errors in scripts that
previously worked. For example, if the right-hand side becomes invalid
for certain negative arguments and this argument is close to $0$.

\paragraph{\blist{stst_stabil} and \blist{get_pts_h_new}}
In the computation of eigenvalues of equilibria an a-priori heuristics
estimates where eigenvalues can lie in the complex plane and adjusts
the discretization stepsize accordingly (see \cite{VLR08} for
technical details). The original implementation resulted in error
messages in various common situations, for example, if the system had
more than $3$ delays, if all delays were zero, or if the estimates
returned only  real parts less than \blist{minimal_real_part}.


\paragraph{Additional auxiliary functions}
\begin{itemize}
\item \blist{p_dot} computes the dot product between two points of
  kind \blist{'psol'}. The function uses the Gauss weights for the
  evaluation of the integral. The options \blist{'free_par_ind'}
  (default empty) and \blist{'period'} (default \blist{false}) set
  which free parameters (non-zero list of indices are included into
  the dot product. The option \blist{'derivatives'} (default
  \blist{[0,0]}) sets hiw often each of the two profiles is
  differentiated before taking the dot product (useful for computing
  products of type $\int_0^1(\dot p(t))^Tq(t)\d t$).
% \item \blist{monodromy_matrix} extracts monomdromy matrix from
%   Jacobian created by \blist{psol_jac}. The code is taken factored out
%   of \blist{mult_app} for possible re-use in other functions.
\item \blist{delay_zero_cond} is a function that has a format suitable
  for use with \blist{method.extra_condition}. It returns the residual
  and the Jacobian for $\tau_j(t_z)=0$ for point types
  \blist{'stst'},\blist{'hopf'} and \blist{'fold'}, and
  $\tau_j(t_z)=0$, $\tau'_j(t_z)=0$ for point type \blist{'psol'}.
\item \blist{VAopX} and \blist{sparse_blkdiag} functions enabling
  vectorized matrix multiplication. For a $n\times m\times p$ array
  \blist{A} and a $m\times q\times p$ array \blist{B}
  \begin{lstlisting}
    C=VAopX(A,B,'*')
  \end{lstlisting}
  gives an $n\times q\times p$ array \blist{C} consisting of the
  matrix products for each of the $p$ stacked matrices.
\item \blist{psol_sysvals} checks if \blist{funcs.x_vectorized} is set
  and performs user function calls (either vectorized or not). This part
  has been factored out of \blist{psol_jac} to make \blist{psol_jac}
  less complex.
\item \blist{dde_set_options} is an auxiliary routine used for
  treatment of optional arguments.
\end{itemize}

\section{List of demos}\label{sec:demos}
\begin{compactitem}
\item \textbf{\texttt{minimal\_demo}}: Duffing oscillator with delayed
  feedback. The delay is a parameter \cite{YP09}. This demonstrates
  usage of \blist{set_funcs} and continuation of folds and torus
  bifurcations of periodic orbits in two parameters.
\item \textbf{\texttt{Mackey-Glass}}: Mackey-Glass equation
  \begin{displaymath}
    \dot x(t)=\beta
  \frac{x(t-\tau)}{1+x(t-\tau)^n}-\gamma x(t)\mbox{.}
\end{displaymath}
(\url{http://www.scholarpedia.org/article/Mackey-Glass_equation}). The
delay is a parameter. This demonstrates the continuation of period
doublings in two parameters. This demo has a switch
\blist{x_vectorize} at the top. Change it to \blist{false} to see the
effect of vectorization on speed.
% \item \textbf{\texttt{Bando}}: $N$ Cars on a ring road with delays due to
%   reaction time (model is taken from \cite{OWES10}). This demonstrates
%   the continuation of folds of periodic orbits in a $2N$-dimensional
%   model ($N=10$ by default).
\item \textbf{\texttt{nested}}: Demonstrates continuation of periodic
  orbits, computation of their stability and continuation of fold of
  periodic orbits in two parameters for a system with state-dependent delays and arbitrary levels of nesting. The default system is
  \begin{displaymath}
    \dot x(t)=x(t-p_1-x(t-p_1-x(t-p_1-x(t))))+p_2x^5\mbox{.}
  \end{displaymath}
\item \textbf{\texttt{humphriesetal}}: example studied in \cite{HDMU12},
%rhs=@(x,p)-p(5)*x(1,1,:)-p(1)*x(1,2,:)-p(2)*x(1,3,:);
%sys_ntau=@()2;
%tau=@(nr,x,p)p(2+nr)+p(6)*x(1,1,:);
%-gamma*x(t)-kappa1*x(t-a1-c*x(t))-kappa2*x(t-a2-c*x(t))
  \begin{displaymath}
    \dot x(t)=-\gamma x(t)-\kappa_1x(t-\alpha_1-cx(t))-
    \kappa_2x(t-\alpha_2-cx(t))\mbox{.}
  \end{displaymath}
  Demonstrates continuation of folds of periodic orbits and torus
  bifurcations for an equation with state-dependent delay.
% \item \textbf{\texttt{turning}}: model for turning with finite
%   stiffness of the tool in lateral direction \cite{IBS08}. The
%   implicit definition of the (state-dependent) delay is converted into
%   an ordinary differential equation for the delay using Baumgarte
%   reduction. The example deomnstrates the continuation of folds of
%   periodic orbits.
\end{compactitem}

\subsection{Relative equilibria and periodic orbits in systems with
  rotational symmetry}
\label{sec:rot}

As a showcase demonstrating how the change of DDE-BifTool's user
interface permits one to extend its functionality, the subfolder
\texttt{ddebiftool\_extra\_rotsym} and the demo \texttt{rotsym\_demo}
are included. The routines in \texttt{ddebiftool\_extra\_rotsym}
enable users to track relative equilibria and periodic orbits of DDE
systems with rotational symmetry and constant delays. Specifically, if
the right-hand side of the DDE
\begin{equation}\label{eq:rot}
  \dot x=f(x(t),x(t-\tau_1),\ldots,x(t-\tau_{n_\tau}),p)
\end{equation}
satisfies
\begin{displaymath}
  \exp(A\phi)f(x_0,x_1,\ldots,x_{n_\tau},p)=
  f(\exp(A\phi)x_0,\exp(A\phi)x_1,\ldots,
  \exp(A\phi)x_{n_\tau},p)
\end{displaymath}
for some anti-symmetric matrix $A$ ($A^T=-A$) and all $\phi\in\R$,
$x_0$,\ldots,$x_{n_\tau}\in\R^n$ and parameters $p$, then
\eqref{eq:rot} possesses two special types of solutions:
\begin{compactitem}
\item \emph{Relative equilibria} (or \emph{rotating waves}). These are
  periodic orbits of the the form
  \begin{equation}
    x(t)=\exp(A\rho t)x_0\mbox{.}\label{eq:rw}
\end{equation}
\item \emph{Relative periodic orbits} (or \emph{modulated
    waves}. These are invariant two-tori of the form
  \begin{equation}
    x(t)=\exp(A(\rho t+\phi))x_0(t)\label{eq:mw}
  \end{equation}
  for all $t\in\R$ and some $\phi\in\R$ and periodic function
  $x_0(\cdot)$ (that is, $x_0(t)=x_0(t+T)$ for all $t\in\R$ and some $T>0$).
\end{compactitem}
For DDE-BifTool to be useful for DDEs with rotational symmetry, it
has to be able to continue relative equilibria and their bifurcations
similar to classical equilibria, and relative periodic orbits and their
bifurcations similar to classical periodic orbits. The function
\blist{set_rotfuncs} in \texttt{ddebiftool\_extra\_rotsym} creates a
right-hand side \blist{rot_rhs} out of the user-given right-hand side
$f$ and the matrix $A$ (and $\exp(A)$ if provided) in rotating
coordinates. The rotation frequency $\rho$ is an additional unknown
that gets fixed with an additional phase condition (in
\blist{rot_cond}). The other functions in
\texttt{ddebiftool\_extra\_rotsym} create wrappers around their
classical counterparts found in \texttt{ddebiftool\_extra\_psol}. The
demo \texttt{rotsym\_demo} shows how to use the extensions for
rotational symmetry for the Lang-Kobayashi equations \cite{LK80}.

\section{Octave compatibility considerations}
\label{sec:octave}

\paragraph{\blist{nargin} incompatibility}
The original DDE-BifTool code was likely
\texttt{octave}
compatible. The changes, replacing function names by function handles,
broke this compatibility initially, because, for example, the call
\blist{nargin(sys_tau)} gives an error message in \texttt{octave}
(version 3.2.3) if \blist{sys_tau} is a function handle. To remedy
this problem the additional field \blist{tp_del} is attached to the
structure \blist{funcs} defining the problem. The field
\blist{funcs.tp_del} is set in \blist{set_funcs}.

\paragraph{Output}
The gradual updating of plots using \blist{drawnow} slows down for the
\texttt{gnuplot}\footnote{\url{http://www.gnuplot.info/}}-based plot
interface of \texttt{octave} as points get added to the plot. Setting
the field \blist{continuation.plot} to \blist{0.5} (that is, less than
$1$ but larger than $0$), prints the values on the screen instead of
updating the plot.

Other useful options:
\begin{compactitem}
\item \blist{page_output_immediately(true);} prints out the results of any
  \blist{fprintf} or \blist{disp} commands immediately
\item \blist{page_screen_output(false);} stops paging the terminal output.
\end{compactitem}

\section{To do}
\label{sec:todo}

\begin{compactitem}
\item Stability computation for equilibria with the new more efficient
  heuristics results in error and wrong results sometimes (for example
  when one has a moderately large delay with a small coefficient in
  front of the delayed term). This is an old bug.
\item Adapt routines for connecting orbits (point type
  \blist{'hcli'}) to exploit vectorization and remove code duplication.
\item Implement \blist{sys_deri_SD_POfold} and
  \blist{sys_deri_SD_TorusBifurcation}. At the moment these are
  approximated by finite differences.
% \item Implement features ``on the outside'' as extended systems. For
%   example, detection and continuation of solutions which have a
%   minimal $\tau(x,p)=0$. This is currently incorporated as an aside into
%   \blist{p_correc}.
\item Ensure full functionality for delays with mixed signs (mostly
  the stability computations have to be adapted).
\item (Possibly) enable implicit differential equations by passing on
  a constant mass matrix to be put in front of the left-hand side (see
  \texttt{knut}\footnote{\url{http://gitorious.org/knut}}
  \cite{RS07}). The changes for periodic orbits and their stability
  are straightforward. The stability computation for equilibria would
  require substantial changes.
\end{compactitem}

{\small\bibliographystyle{unsrt} \bibliography{manual}
}


\end{document}
